#### Functions +++ Visualization ####

#' Draws the hexagonal lattice
#' 
#' @param edges a data.frame, as generated by @code compute_edges 
#' @param add Either NULL or a ggplot object
#' @param z Either NULL or a numeric vector with a Z value to produce a heatmap
#' @param ... Additional parameters to be passed to ggplot (color, size, alpha ...)
#' @return A ggplot object drawing the hexagonal lattice on top of whatever (if any)
#' layer is passed to the argument add. The colour of the hexagons will be based on
#' the values provided in \code{z} (if any, black otherwise).
draw_hexagons <- function(edges = NULL, add = NULL, z = NULL, ...){
        
        if(is.null(edges)){
                edges <- compute_edges(hex[hex$y > 1000, ])
        }
        
        if(!is.null(add)){
                pl <- add
        } else {
                pl <- ggplot()
        }
        
        if(!is.null(z)){
                pl <- pl + geom_segment(data = edges, 
                                        aes(x = x, xend = xend, y = y, yend = yend, color = z), ...)
                
        } else {
                pl <- pl + geom_segment(data = edges, aes(x = x, xend = xend, y = y, yend = yend), ...)
                
        }
        pl + xlab('') + ylab('') + theme(axis.text = element_blank(), axis.ticks = element_blank(),
                                         axis.line = element_blank())
}


draw_nodes <- function(coords = NULL, add = NULL, z = NULL, ...){
        
        if(is.null(coords)){
                hex <- hex[hex$y > 1000, ]
        } else {
                hex <- coords
        }
        
        if(!is.null(add)){
                pl <- add
        } else {
                pl <- ggplot()
        }
        
        if(!is.null(z)){
                pl <- pl + geom_point(data = hex, 
                                        aes(x = x, y = y, fill = z), shape = 21, ...)
        } else {
                head(hex)
                pl <- pl + geom_point(data = hex, aes(x = x, y = y), shape = 21,...)
        }
        pl + xlab('') + ylab('') + theme(axis.text = element_blank(), axis.ticks = element_blank(),
                                         axis.line = element_blank())
}


draw_traffic_flow <- function(edges = NULL, add = NULL, ...){
        
        if(is.null(edges)){
                edges <- compute_edges(hex[hex$y > 1000, ])
        }
        
        if(!is.null(add)){
                pl <- add
        } else {
                pl <- ggplot()
        }
        
        pl <- pl + geom_segment(data = edges, 
                                aes(x = x, xend = xend, y = y,
                                    yend = yend, size = z**1.2), color = 'black',
                                show.legend = FALSE, ...) +
                geom_segment(data = edges, 
                             aes(x = x, xend = xend, y = y,
                                 yend = yend, color = z, size = z), ...)
        
        pl + xlab('') + ylab('') + theme(axis.text = element_blank(), axis.ticks = element_blank(),
                                         axis.line = element_blank())
}

geom_circle <- function(center, r, npoints = 100, ...){
     sq <- seq(0, 2*pi, length.out = npoints)
     if(is.data.frame(center)){
          
          if(nrow(center) == 1){
               x <- center[, 1] + r * cos(sq)
               y <- center[, 2] + r * sin(sq)
               geom_path(data = data.frame(x = x, y = y), aes(x, y), ...)
          } else {
               x <- c()
               y <- c()
               g <- c()
               for(i in seq_len(nrow(center))){
                    x <- c(x, center[i, 1] + r * cos(sq))
                    y <- c(y, center[i, 2] + r * sin(sq))
                    g <- c(g, rep(i, npoints))
               }
               geom_path(data = data.frame(x = x, y = y, g = g), aes(x, y, group = factor(g)), ...)
          }
          
     } else if (is.atomic(center) && length(center) == 2){
          
          geom_path(data = data.frame(x = center[1] + r * cos(sq),
                                      y = center[2] + r * sin(sq)),
                    aes(x, y, group = factor(g)), ...)
     } else {
          stop('Please use a data.frame or an atomic vector of length two for the center')
     }
     
}

geom_foodpatches <- function(food = NULL, add = NULL, ...){
        if(is.null(add)){
                add <- ggplot()
        }
        if(is.null(food)){
                food <- get_foodPatches('20180720M')[1:2]
        }
        
        func <- function(x, add = add){
                for(i in seq_along(x[1:2])){
                        f <- x[[i]][chull(x[[i]][, c('x', 'y')]), ]
                        add <- add + geom_polygon(data = f, aes(x, y), ...) +
                                xlab('') + ylab('')
                }
                add
        }

        
        if(any(grepl('P', names(food)))){
                add <- func(food, add)
        } else {
                for(i in seq_along(food)){
                        add <- func(food[[i]], add)
                }
        }

        add
}

geom_food <- function(t,  
                      rectangle_params = list(fill = muted('green'),
                                              color = 'green', 
                                              alpha = 0.15, linetype = 2, size = 1),
                      complete = FALSE, ylim = c(-Inf, Inf)){
        
        ylim <- sort(ylim)
        trange <- range(t)
        
        rectangle_params$data <- data.frame(x = c(trange[1], trange[1], trange[2], trange[2]),
                                            y = c(ylim[1], ylim[2], ylim[2], ylim[1]))
        rectangle_params$mapping <- aes(x, y)
        
        rectangle_geom <- do.call('geom_polygon', args = rectangle_params)
        
        if(complete){
                segment_params <- rectangle_params
                segment_params$fill <- NULL
                segment_params$alpha <- 1
                segment_params$size <- 0.5
                segment_params$data <- data.frame(x = t[t > trange[1] & t < trange[2]],
                                                  y = ylim[1], yend = ylim[2])
                
                segment_params$mapping <- aes(x = x, xend = x, y = y, yend = yend)
                
                food_geom <- do.call('geom_segment', args = segment_params)
                
                return(list(rectangle_geom, food_geom))
        }
        
        rectangle_geom
}

## Function to enhance resolution of a heatmap
enhance_land_res <- function(land, xvar, yvar, zvar, spar=0.5, n = 200){
        x <- seq(min(land[[xvar]]), max(land[[xvar]]), length.out = n)
        y <- seq(min(land[[yvar]]), max(land[[yvar]]), length.out = n)
        ## Loop over xvar
        yDT <- rbindlist(lapply(unique(land[[xvar]]), function(xi){
                indx <- which(land[[xvar]] == xi)
                data.table(x=xi, y=y, z=predict(smooth.spline(land[[yvar]][indx], land[[zvar]][indx], spar=spar),
                                                y)$y)
        }))
        
        ## Loop over yvar
        res <- rbindlist(lapply(unique(yDT[['y']]), function(yi){
                indx <- which(yDT[['y']] == yi)
                data.table(x=x, y=yi, z=predict(smooth.spline(yDT[['x']][indx], yDT[['z']][indx], spar=spar),
                                                x)$y)
        }))
        
        ## Rename land
        setnames(res, old=c('x','y','z'), new=c(xvar, yvar, zvar))
        
        ## Reorder land
        setorderv(res, cols=xvar)
        
        ## Return land
        res
}  
